
@menu
* A technical description of the position ID::
* A technical description of the match ID::
@end menu

@node A technical description of the position ID
@section A technical description of the position ID
@cindex position ID

@subsection Introduction

This section describes a method for compactly recording a backgammon
position. It demonstrates how to encode a position into 10 binary
bytes, which is useful for minimising the space used when recording
large numbers of positions in memory or on disk. There is also an
ASCII representation in 14 characters, which is convenient for output
to the screen, for copying and pasting to transfer positions between
programs which support the format, and for communicating positions via
Usenet news or e-mail. The 10 byte binary format is called the @emph{key},
and the 14 character ASCII format is the @emph{ID}. 

@subsection Key format

The key is essentially a bit string (imagine you start with an empty
sequence of bits, and continue adding either "0" or "1" to the
end). The way to build up a sequence that corresponds to a given
position is: 

@enumerate
@item  For every point around the board (starting at the ace point of
the player on roll, continuing around to the 24 point and ending at
the bar): 
@enumerate
@item append as many 1s as the player on roll has on that point (if any).
@item append a 0. 
@end enumerate

@item For every point around the board (starting at the ace point of
the opponent, continuing around to the opponent's 24 point and ending
at the bar): 
@enumerate
@item append as many 1s as the opponent has on that point (if any).
@item append a 0. 
@item Pad out the string to 80 bits with 0s. 
@end enumerate

@end enumerate

The worst-case representation will require 80 bits: you can see that
there are always 50 0 bits even if there are no chequers at all. Each
player has a maximum of 15 chequers in play (not yet borne off) which
require a 1 bit wherever they are positioned. That's 30 bits to take
of all chequers, plus the 50 bits of overhead for a total of 80 bits
(the last bit is always 0 and isn't strictly necessary, but it makes
the code slightly easier). This bit string should be stored in
little-endian order when packed into bytes (ie. the first bits in the
string are stored in the least significant bits of the first byte). 

As an example, here's what the starting position looks like in the key
format:

@multitable @columnfractions 0.33 0.33
@item 0 0 0 0 0          @tab player on roll has no chequers on ace to 5 points
@item 11111 0            @tab 5 chequers on the 6 point
@item 0                  @tab empty bar
@item 111 0              @tab 3 on the 8
@item 0 0 0 0            @tab no others in our outfield
@item 11111 0            @tab 5 on the midpoint
@item 0 0 0 0 0          @tab none in the opponent's outfield
@item 0 0 0 0 0          @tab or in opponent's board, until...
@item 11 0               @tab two on the 24 point
@item 0                  @tab none on the bar
@item 0 0 0 0 0          @tab opponent has no chequers on ace to 5 points
@item 11111 0            @tab 5 chequers on the 6 point
@item 0                  @tab empty bar
@item 111 0              @tab 3 on the 8
@item 0 0 0 0            @tab no others in opponent's outfield
@item 11111 0            @tab 5 on the midpoint
@item 0 0 0 0 0          @tab none in our outfield
@item 0 0 0 0 0          @tab or in our board, until...
@item 11 0               @tab two on the 24 point
@item 0                  @tab none on the bar
@end multitable

so altogether it's:

00000111110011100000111110000000000011000000011111001110000011111000000000001100

In little endian bytes it looks like:

11100000 01110011 11110000 00000001 00110000 11100000 01110011 11110000 00000001 00110000
   0xE0     0x73     0xF0     0x01     0x30     0xE0     0x73     0xF0     0x01     0x30

so the 10 byte key (in hex) is E0 73 F0 01 30 E0 73 F0 01 30.
ID format

The ID format is simply the 
@uref{http://www.ietf.org/rfc/rfc2045.txt,Base64}
encoding of the key. (Technically,
a Base64 encoding of 80 binary bits should consist of 14 characters
followed by two = padding characters, but this padding is omitted in
the ID format.) 

To continue the above example, splitting the 10 8-bit bytes into 14
6-bit groups gives: 

111000 000111 001111 110000 000000 010011 000011 100000 011100 111111 000000 000001 001100 000000

In Base64 encoding, these groups are respectively represented as:

4      H      P     w      A      T      D      g      c      /      A      B      M      A

So, the position ID of the chequers at the start of the game is simply:

4HPwATDgc/ABMA

You can set the board in @gnubg{} either by writing the position ID
into the position text input field in the GUI or by executing the
command @code{set board 4HPwATDgc/ABMA}.

@subsection Notes

@itemize
@item This encoding is obviously not as compact as it could be: in
particular, there are lots of redundant representations of illegal
positions where both players have chequers on the same
point. Theoretically, it would be possible to get it down to 64 bits
by using 
@uref{http://www.bkgm.com/rgb/rgb.cgi?view+371,Walter Trice's
"D() expressions"}, but I think you'd have to 
be a mathematical masochist to try it! 
@item 
@uref{http://savannah.gnu.org/cgi-bin/viewcvs/gnubg/gnubg/positionid.c?rev=HEAD&sortby=date&content-type=text/vnd.viewcvs-markup,Example
code} 
to convert between a raw board encoding (the number of chequers on
each point) and these keys/IDs is available licensed under GPL. 
@item Thanks to Tom Keith and David desJardins for their suggestions
on simplifying the encoding without increasing the worst case length.  
@end itemize

@node A technical description of the match ID
@section A technical description of the match ID
@cindex match ID

@subsection Introduction

This section describes how the match ID is calculated. The match ID  can
be used for easy exchange of positions for @gnubg{} users in
conjuction with the position ID. The match key is a 9 byte
representation of the match score, match length, value of cube, owner of
cube, Crawford game flag, player on roll, player to make a decision,
doubled flag, resigned flag, and the dice rolled. The match ID is the 12
character Base64 encoding of the match key.

@subsection Match key

The match key is a bit string of length 66:

@enumerate
@item
Bit 1-4 contains the 2-logarithm of the cube value. For example, a
8-cube is encoded as 0011 binary (or 3), since 2 to the power of 3 is
8. The maximum value of the cube in with this encoding is 2 to the power
of 15, i.e., a 32768-cube.

@item
Bit 5-6 contains the cube owner. 00 if player 0 owns the cube, 01 if
player 1 owns the cube, or 11 for a centered cube.

@item
Bit 7 is the player on roll or the player who did roll (0 and 1 for
player 0 and 1, respectively).  

@item
Bit 8 is the Crawford flag: 1 if this game is the Crawford game, 0
otherwise.

@item
Bit 9-11 is the game state: 000 for no game started, 001 for playing a game,
010 if the game is over, 011 if the game was resigned, or 100 if the
game was ended by dropping a cube.

@item
Bit 12 indicates whose turn it is. For example, suppose player 0 is on
roll then bit 7 above will be 0. Player 0 now decides to double, this
will make bit 12 equal to 1, since it is now player 1's turn to decide
whether she takes or passes the cube.

@item
Bit 13 indicates whether an doubled is being offered. 0 if no double is
being offered and 1 if a double is being offered.

@item
Bit 14-15 indicates whether an resignation was offered. 00 for no
resignation, 01 for resign of a sigle game, 10 for resign of a gammon,
or 11 for resign of a backgammon. The player offering the resignation is
the inverse of bit 12, e.g., if player 0 resigns a gammon then bit 12
will be 1 (as it is now player 1 now has to decide whether to accept or
reject the resignation) and bit 13-14 will be 10 for resign of a gammon.

@item
Bit 16-18 and bit 19-21 is the first and second die, respectively. 0 if
the dice has not yet be rolled, otherwise the binary encoding of the
dice, e.g., if 5-2 was rolled bit 16-21 will be 101-010.

@item
Bit 22 to 36 is the match length. The maximum value for the match length
is 32767. A matchscore of zero indicates that the game is a money game.

@item
Bit 37-51 and bit 52-66 is the score for player 0 and player 1
respectively. The maximum value of the match score is 32767.

@end enumerate

For example, assume the score is 2-4 in a 9 point match with player 0
holding a 2-cube, and player 1 has just rolled 52. The match key for
this will be (note that the bit order is reversed below for readability)

1000 00 1 0  100 1 0 00 101 010 100100000000000 010000000000000 001000000000000            


In little endian the bytes looks like:

01000001 10001001 00101010 00000001 00100000 00000000 00100000 00000000 00

0x41     0x89     0x2A     0x01     0x20     0x00     0x20     0x00     0x00

@subsection Match ID

Analogous to the position ID from the previous section the match ID
format is simply the Base64 encoding of the key. 

To continue the example above, the 9 8-bit bytes are grouped into 12
6-bits groups:


010000 011000 100100 101010 000000 010010 000000 000000 001000 000000
000000 000000

In Base64 encoding, the groups are represented as:

Q Y k q A S A A I A A A

So, the match id is simply:

QYkqASAAIAAA

If someone post a match ID you can set up the position in @gnubg{} by
writing or pasting it into the Match ID text input field on the main
window, or by executing the command @code{set matchid QYkqASAAIAAA}.


